# [1교시] 개념잡기 - RxSwift를 사용한 비동기 프로그래밍

+ 기존의 비동기적 처리에 있어서 func을 함수를 value 처럼 변수에 담아 파라미터로 받아 핸들러로 사용
+ @esacaping은 전달된 함수가 본체의 스코프가 종료된 후에 사용되는 경우로 파라미터를 optional로 전달 시 default가 @esacaping
+ 함수는 행동을 저장하고 이러한 행동은 나중에 사용이 가능 - 함수형 프로그래밍 기반
+ 해당 개념을 제네릭과 엮어서 만든 것이 RxSwift
+ 개인적으로 Generator의 개념도 섞인게 아닐까 싶음(iterator.next())
+ Observable이 이벤트를 발생시키면 옵저버의 관찰자가 그 순간을 감지하고 하고 '순차적으로 분리 된' 방식으로 처리함으로써 '비동기식' 기능 구현이 가능
+ 기존의 비동기 처리 방식: Notification Center, Delegate pattern, Grand Central Dispatch(GCD), Closures + promiseKit, Bolts

## 1. Observable
+ 생성
  + create: AnyObserver<T> 타입의 emitter 방출, next, error, completed의 세 가지 타입의 유형으로 switch 문을 통해 제어
  + 간단한 생성: just, from
+ 필터: filter, take
+ 변환: map, flatMap, scan
+ 결합: combineLatest, merge, zip
+ 유틸: do, delay, observeOn, subscribeOn

# [2교시] RxSwift 활용하기 - 쓰레드의 활용과 메모리 관리

## 1. Observable Life-Cycle
Observable은 subscription을 받기 전까진 아무 짓도 하지 않은채 값을 가지고만 있다.
즉, subscription이 Observable이 이벤트들을 방출하도록 해줄 방아쇠 역할을 한다
+ Subscribed: Observable 객체를 감시하여 객체의 value의 변화에 따른 Subscribed 메서드 동작
+ Next: 구독을 통하여 이벤트를 계속해서 방출받을 수 있는 상태, Element 인스턴스를 가짐
+ Completed / Error: 구독이 완료/에러발생으로 종료된 상태, .error 이벤트는 Swift.Error 인스턴스를 가짐
+ Disposabled: 구독을 취소하여 Observable을 수동적으로 종료

## 2. 순환 참조와 메모리 관리
self 값에 대한 참조에 있어서 weak를 이용한 순환 참조 해결
클로저의 캡처 리스트에 있어서 참조 타입(Class)의 레퍼런스 카운트 주의
특히 UI 관련 사이드 이펙트에 있어서 주의
edit scheme - Diagnostics - malloc 설정으로 해당 앱 실행에 있어서 메모리 leak 체크 가능
[weak self] 와 같은 귀찮은 코드를 하지 않더라도, 종료조건이나 시점을 통제함으로써 메모리를 관리할 수 있다.

## 3. Thread/Scheduler 분기
observeOn(원하는 시점 부터), subscribeOn(구독 시작 부터) 메서드를 사용하여 UX에 있어서 비동기적인 활용을 위한 thread 컨트롤

## 4. Stream의 병합 및 공유
+ 병합
  + combine, merge, zip을 활용하여 Observable 병합
+ 공유
  + 1개의 이벤트를 여러 Observer가 구독하여 공유, observing하기 전 과거 elements를 어떻게 다룰지(replay)와 언제 공유할지(refCount)가 필요, replay(1).refCount(), 합쳐서 share(replay: 1)로 사용






